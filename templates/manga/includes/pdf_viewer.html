
<!-- PDF Viewer -->
{% if chapter.preview or chapter.pdf %}
  <div class="pdf-viewer-container relative">
    {# 1) Моментальное превью #}
    {% if chapter.preview %}
      <img
        id="pdf-preview"
        src="{{ chapter.preview.url }}"
        alt="Preview страницы {{ chapter.chapter_number }}"
        class="block w-full h-auto"
      >
    {% endif %}

    {# 2) Контейнер для canvas (скрыт до готовности) #}
    <div id="pdf-canvas-wrapper" class="absolute inset-0 hidden"></div>

    {# 3) Спиннер #}
    <div id="pdf-loading" class="absolute inset-0 flex items-center justify-center z-10">
      <div class="spinner"></div>
    </div>
  </div>

  {# CSS (можно вынести в отдельный файл) #}
  <style>
    .pdf-viewer-container {
      position: relative;
      max-width: 100%;
      margin: 0 auto;
      padding: 0;
      min-height: calc(100vh - var(--navbar-height, 56px));
      background: #fff;
    }
    .spinner {
      width: 3rem;
      height: 3rem;
      border: 4px solid #e5e7eb;
      border-top-color: #6366f1;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .pdf-page {
      position: absolute;
      top: 0; left: 50%;
      transform: translateX(-50%);
      max-width: 100%;
      height: auto;
    }
  </style>

  {# JS: сначала показываем превью, затем подгружаем и рендерим первую страницу Canvas #}
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const url       = "{{ chapter.pdf.url }}";
      const preview   = document.getElementById('pdf-preview');
      const canvasWrap= document.getElementById('pdf-canvas-wrapper');
      const loader    = document.getElementById('pdf-loading');
      const navbar    = document.getElementById('navbar');
      const container = document.querySelector('.pdf-viewer-container');

      // Подгоняем высоту под navbar
      const navH = navbar?.offsetHeight || 0;
      container.style.minHeight = (window.innerHeight - navH) + 'px';

      async function renderFirstPage() {
        // Инициализируем PDF.js с Range-запросами
        const loadingTask = pdfjsLib.getDocument({ url, disableStream: false, disableRange: false });
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(1);

        // Подбираем масштаб по ширине превью
        const cw = (preview?.clientWidth) || container.clientWidth;
        const vp = page.getViewport({ scale: 1 });
        const baseScale = Math.min(cw / vp.width, 1);
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        const scale = baseScale * dpr;
        const viewport = page.getViewport({ scale });

        // Создаём canvas и рендерим
        const canvas = document.createElement('canvas');
        canvas.width  = viewport.width;
        canvas.height = viewport.height;
        canvas.className = 'pdf-page';
        const ctx = canvas.getContext('2d');
        await page.render({ canvasContext: ctx, viewport }).promise;

        // Заменяем превью на canvas
        if (preview) preview.remove();
        canvasWrap.appendChild(canvas);
        canvasWrap.classList.remove('hidden');

        // Скрываем спиннер
        loader.style.display = 'none';

        // Опционально: продолжить ленивую подгрузку остальных страниц
        lazyLoadRemaining(pdf, scale, baseScale);
      }

      function lazyLoadRemaining(pdf, scale, baseScale) {
        const observer = new IntersectionObserver(async entries => {
          for (const e of entries) {
            if (e.isIntersecting) {
              const num = +e.target.dataset.page;
              const pg = await pdf.getPage(num);
              const vp = pg.getViewport({ scale });
              const cn = document.createElement('canvas');
              cn.width  = vp.width;
              cn.height = vp.height;
              cn.className = 'pdf-page';
              const ctx = cn.getContext('2d');
              await pg.render({ canvasContext: ctx, viewport: vp }).promise;
              e.target.replaceWith(cn);
              observer.unobserve(e.target);
            }
          }
        }, { rootMargin: '200px' });

        const placeholderH = (pdf.getPage(1).then(p => p.getViewport({ scale: 1 }).height * baseScale)) + 'px';
        for (let i = 2; i <= pdf.numPages; i++) {
          const ph = document.createElement('div');
          ph.dataset.page = i;
          ph.style.width  = '100%';
          ph.style.height = placeholderH;
          ph.className    = 'pdf-page';
          canvasWrap.parentNode.appendChild(ph);
          observer.observe(ph);
        }
      }

      // Стартуем фоновый рендер первой страницы
      renderFirstPage().catch(err => {
        console.error("PDF.js error:", err);
        loader.innerText = "Не удалось загрузить PDF. Обновите страницу.";
      });
    });
  </script>
{% endif %}
